// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "bff.proto" (package "game.bff", syntax proto3)
// tslint:disable
import { CommonResponse } from "./types";
import { CommonRequest } from "./types";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { CallData } from "./types";
import { ModelStatus } from "./agent";
import { ModelBuffer } from "./agent";
import { ModelWeights } from "./agent";
import { AgentMode } from "./agent";
import { AgentConfig } from "./agent";
import { SimInfo } from "./simenv";
import { SimCmd } from "./simenv";
import { SimenvConfig } from "./simenv";
import { ServiceState } from "./types";
/**
 * @generated from protobuf message game.bff.ServiceInfo
 */
export interface ServiceInfo {
  /**
   * @generated from protobuf field: string type = 1;
   */
  type: string; // type of service, predefine: simenv/agent
  /**
   * @generated from protobuf field: string name = 2;
   */
  name: string;
  /**
   * @generated from protobuf field: string host = 3;
   */
  host: string;
  /**
   * @generated from protobuf field: uint32 port = 4;
   */
  port: number;
  /**
   * @generated from protobuf field: string desc = 5;
   */
  desc: string;
}
/**
 * @generated from protobuf message game.bff.ServiceIdList
 */
export interface ServiceIdList {
  /**
   * @generated from protobuf field: repeated string ids = 1;
   */
  ids: string[]; // id list of services
}
/**
 * @generated from protobuf message game.bff.ServiceInfoMap
 */
export interface ServiceInfoMap {
  /**
   * @generated from protobuf field: map<string, game.bff.ServiceInfo> services = 1;
   */
  services: {
    [key: string]: ServiceInfo;
  }; // <service id, service info>
}
/**
 * @generated from protobuf message game.bff.RouteConfig
 */
export interface RouteConfig {
  /**
   * @generated from protobuf field: map<string, game.bff.RouteConfig.Route> routes = 1;
   */
  routes: {
    [key: string]: RouteConfig_Route;
  }; // <simenv id, route>
}
/**
 * @generated from protobuf message game.bff.RouteConfig.Config
 */
export interface RouteConfig_Config {
  /**
   * @generated from protobuf field: repeated string models = 1;
   */
  models: string[]; // name list of models
}
/**
 * @generated from protobuf message game.bff.RouteConfig.Route
 */
export interface RouteConfig_Route {
  /**
   * @generated from protobuf field: map<string, game.bff.RouteConfig.Config> configs = 1;
   */
  configs: {
    [key: string]: RouteConfig_Config;
  }; // <agent id, config>
}
/**
 * @generated from protobuf message game.bff.ServiceStateMap
 */
export interface ServiceStateMap {
  /**
   * @generated from protobuf field: map<string, game.types.ServiceState> states = 1;
   */
  states: {
    [key: string]: ServiceState;
  }; // <service id, service state>
}
/**
 * @generated from protobuf message game.bff.SimenvConfigMap
 */
export interface SimenvConfigMap {
  /**
   * @generated from protobuf field: map<string, game.simenv.SimenvConfig> configs = 1;
   */
  configs: {
    [key: string]: SimenvConfig;
  }; // <simenv id, simenv config>
}
/**
 * @generated from protobuf message game.bff.SimCmdMap
 */
export interface SimCmdMap {
  /**
   * @generated from protobuf field: map<string, game.simenv.SimCmd> cmds = 1;
   */
  cmds: {
    [key: string]: SimCmd;
  }; // <simenv id, simenv cmd>
}
/**
 * @generated from protobuf message game.bff.SimInfoMap
 */
export interface SimInfoMap {
  /**
   * @generated from protobuf field: map<string, game.simenv.SimInfo> infos = 1;
   */
  infos: {
    [key: string]: SimInfo;
  }; // <simenv id, simenv info>
}
/**
 * @generated from protobuf message game.bff.AgentConfigMap
 */
export interface AgentConfigMap {
  /**
   * @generated from protobuf field: map<string, game.agent.AgentConfig> configs = 1;
   */
  configs: {
    [key: string]: AgentConfig;
  }; // <agent id, agent config>
}
/**
 * @generated from protobuf message game.bff.AgentModeMap
 */
export interface AgentModeMap {
  /**
   * @generated from protobuf field: map<string, game.agent.AgentMode> modes = 1;
   */
  modes: {
    [key: string]: AgentMode;
  }; // <agent id, agent mode>
}
/**
 * @generated from protobuf message game.bff.ModelWeightsMap
 */
export interface ModelWeightsMap {
  /**
   * @generated from protobuf field: map<string, game.agent.ModelWeights> weights = 1;
   */
  weights: {
    [key: string]: ModelWeights;
  }; // <agent id, model weights>
}
/**
 * @generated from protobuf message game.bff.ModelBufferMap
 */
export interface ModelBufferMap {
  /**
   * @generated from protobuf field: map<string, game.agent.ModelBuffer> buffers = 1;
   */
  buffers: {
    [key: string]: ModelBuffer;
  }; // <agent id, model buffer>
}
/**
 * @generated from protobuf message game.bff.ModelStatusMap
 */
export interface ModelStatusMap {
  /**
   * @generated from protobuf field: map<string, game.agent.ModelStatus> status = 1;
   */
  status: {
    [key: string]: ModelStatus;
  }; // <agent id, model status>
}
/**
 * @generated from protobuf message game.bff.CallDataMap
 */
export interface CallDataMap {
  /**
   * @generated from protobuf field: map<string, game.types.CallData> data = 1;
   */
  data: {
    [key: string]: CallData;
  }; // <service id, call data>
}
// @generated message type with reflection information, may provide speed optimized methods
class ServiceInfo$Type extends MessageType<ServiceInfo> {
  constructor() {
    super("game.bff.ServiceInfo", [
      { no: 1, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 4, name: "port", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
      { no: 5, name: "desc", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
    ]);
  }
  create(value?: PartialMessage<ServiceInfo>): ServiceInfo {
    const message = { type: "", name: "", host: "", port: 0, desc: "" };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<ServiceInfo>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ServiceInfo
  ): ServiceInfo {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string type */ 1:
          message.type = reader.string();
          break;
        case /* string name */ 2:
          message.name = reader.string();
          break;
        case /* string host */ 3:
          message.host = reader.string();
          break;
        case /* uint32 port */ 4:
          message.port = reader.uint32();
          break;
        case /* string desc */ 5:
          message.desc = reader.string();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ServiceInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string type = 1; */
    if (message.type !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.type);
    /* string name = 2; */
    if (message.name !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.name);
    /* string host = 3; */
    if (message.host !== "")
      writer.tag(3, WireType.LengthDelimited).string(message.host);
    /* uint32 port = 4; */
    if (message.port !== 0) writer.tag(4, WireType.Varint).uint32(message.port);
    /* string desc = 5; */
    if (message.desc !== "")
      writer.tag(5, WireType.LengthDelimited).string(message.desc);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.bff.ServiceInfo
 */
export const ServiceInfo = new ServiceInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceIdList$Type extends MessageType<ServiceIdList> {
  constructor() {
    super("game.bff.ServiceIdList", [
      {
        no: 1,
        name: "ids",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<ServiceIdList>): ServiceIdList {
    const message = { ids: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<ServiceIdList>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ServiceIdList
  ): ServiceIdList {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string ids */ 1:
          message.ids.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ServiceIdList,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated string ids = 1; */
    for (let i = 0; i < message.ids.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.ids[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.bff.ServiceIdList
 */
export const ServiceIdList = new ServiceIdList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceInfoMap$Type extends MessageType<ServiceInfoMap> {
  constructor() {
    super("game.bff.ServiceInfoMap", [
      {
        no: 1,
        name: "services",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => ServiceInfo },
      },
    ]);
  }
  create(value?: PartialMessage<ServiceInfoMap>): ServiceInfoMap {
    const message = { services: {} };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<ServiceInfoMap>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ServiceInfoMap
  ): ServiceInfoMap {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.bff.ServiceInfo> services */ 1:
          this.binaryReadMap1(message.services, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: ServiceInfoMap["services"],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof ServiceInfoMap["services"] | undefined,
      val: ServiceInfoMap["services"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = ServiceInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options
          );
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.bff.ServiceInfoMap.services"
          );
      }
    }
    map[key ?? ""] = val ?? ServiceInfo.create();
  }
  internalBinaryWrite(
    message: ServiceInfoMap,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, game.bff.ServiceInfo> services = 1; */
    for (let k of Object.keys(message.services)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      ServiceInfo.internalBinaryWrite(message.services[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.bff.ServiceInfoMap
 */
export const ServiceInfoMap = new ServiceInfoMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteConfig$Type extends MessageType<RouteConfig> {
  constructor() {
    super("game.bff.RouteConfig", [
      {
        no: 1,
        name: "routes",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => RouteConfig_Route },
      },
    ]);
  }
  create(value?: PartialMessage<RouteConfig>): RouteConfig {
    const message = { routes: {} };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<RouteConfig>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RouteConfig
  ): RouteConfig {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.bff.RouteConfig.Route> routes */ 1:
          this.binaryReadMap1(message.routes, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: RouteConfig["routes"],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof RouteConfig["routes"] | undefined,
      val: RouteConfig["routes"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = RouteConfig_Route.internalBinaryRead(
            reader,
            reader.uint32(),
            options
          );
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.bff.RouteConfig.routes"
          );
      }
    }
    map[key ?? ""] = val ?? RouteConfig_Route.create();
  }
  internalBinaryWrite(
    message: RouteConfig,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, game.bff.RouteConfig.Route> routes = 1; */
    for (let k of Object.keys(message.routes)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      RouteConfig_Route.internalBinaryWrite(message.routes[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.bff.RouteConfig
 */
export const RouteConfig = new RouteConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteConfig_Config$Type extends MessageType<RouteConfig_Config> {
  constructor() {
    super("game.bff.RouteConfig.Config", [
      {
        no: 1,
        name: "models",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<RouteConfig_Config>): RouteConfig_Config {
    const message = { models: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<RouteConfig_Config>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RouteConfig_Config
  ): RouteConfig_Config {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string models */ 1:
          message.models.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RouteConfig_Config,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated string models = 1; */
    for (let i = 0; i < message.models.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.models[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.bff.RouteConfig.Config
 */
export const RouteConfig_Config = new RouteConfig_Config$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RouteConfig_Route$Type extends MessageType<RouteConfig_Route> {
  constructor() {
    super("game.bff.RouteConfig.Route", [
      {
        no: 1,
        name: "configs",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => RouteConfig_Config },
      },
    ]);
  }
  create(value?: PartialMessage<RouteConfig_Route>): RouteConfig_Route {
    const message = { configs: {} };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<RouteConfig_Route>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RouteConfig_Route
  ): RouteConfig_Route {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.bff.RouteConfig.Config> configs */ 1:
          this.binaryReadMap1(message.configs, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: RouteConfig_Route["configs"],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof RouteConfig_Route["configs"] | undefined,
      val: RouteConfig_Route["configs"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = RouteConfig_Config.internalBinaryRead(
            reader,
            reader.uint32(),
            options
          );
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.bff.RouteConfig.Route.configs"
          );
      }
    }
    map[key ?? ""] = val ?? RouteConfig_Config.create();
  }
  internalBinaryWrite(
    message: RouteConfig_Route,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, game.bff.RouteConfig.Config> configs = 1; */
    for (let k of Object.keys(message.configs)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      RouteConfig_Config.internalBinaryWrite(
        message.configs[k],
        writer,
        options
      );
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.bff.RouteConfig.Route
 */
export const RouteConfig_Route = new RouteConfig_Route$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceStateMap$Type extends MessageType<ServiceStateMap> {
  constructor() {
    super("game.bff.ServiceStateMap", [
      {
        no: 1,
        name: "states",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => ServiceState },
      },
    ]);
  }
  create(value?: PartialMessage<ServiceStateMap>): ServiceStateMap {
    const message = { states: {} };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<ServiceStateMap>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ServiceStateMap
  ): ServiceStateMap {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.types.ServiceState> states */ 1:
          this.binaryReadMap1(message.states, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: ServiceStateMap["states"],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof ServiceStateMap["states"] | undefined,
      val: ServiceStateMap["states"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = ServiceState.internalBinaryRead(
            reader,
            reader.uint32(),
            options
          );
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.bff.ServiceStateMap.states"
          );
      }
    }
    map[key ?? ""] = val ?? ServiceState.create();
  }
  internalBinaryWrite(
    message: ServiceStateMap,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, game.types.ServiceState> states = 1; */
    for (let k of Object.keys(message.states)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      ServiceState.internalBinaryWrite(message.states[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.bff.ServiceStateMap
 */
export const ServiceStateMap = new ServiceStateMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimenvConfigMap$Type extends MessageType<SimenvConfigMap> {
  constructor() {
    super("game.bff.SimenvConfigMap", [
      {
        no: 1,
        name: "configs",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => SimenvConfig },
      },
    ]);
  }
  create(value?: PartialMessage<SimenvConfigMap>): SimenvConfigMap {
    const message = { configs: {} };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<SimenvConfigMap>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SimenvConfigMap
  ): SimenvConfigMap {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.simenv.SimenvConfig> configs */ 1:
          this.binaryReadMap1(message.configs, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: SimenvConfigMap["configs"],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof SimenvConfigMap["configs"] | undefined,
      val: SimenvConfigMap["configs"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = SimenvConfig.internalBinaryRead(
            reader,
            reader.uint32(),
            options
          );
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.bff.SimenvConfigMap.configs"
          );
      }
    }
    map[key ?? ""] = val ?? SimenvConfig.create();
  }
  internalBinaryWrite(
    message: SimenvConfigMap,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, game.simenv.SimenvConfig> configs = 1; */
    for (let k of Object.keys(message.configs)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      SimenvConfig.internalBinaryWrite(message.configs[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.bff.SimenvConfigMap
 */
export const SimenvConfigMap = new SimenvConfigMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimCmdMap$Type extends MessageType<SimCmdMap> {
  constructor() {
    super("game.bff.SimCmdMap", [
      {
        no: 1,
        name: "cmds",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => SimCmd },
      },
    ]);
  }
  create(value?: PartialMessage<SimCmdMap>): SimCmdMap {
    const message = { cmds: {} };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<SimCmdMap>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SimCmdMap
  ): SimCmdMap {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.simenv.SimCmd> cmds */ 1:
          this.binaryReadMap1(message.cmds, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: SimCmdMap["cmds"],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof SimCmdMap["cmds"] | undefined,
      val: SimCmdMap["cmds"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = SimCmd.internalBinaryRead(reader, reader.uint32(), options);
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.bff.SimCmdMap.cmds"
          );
      }
    }
    map[key ?? ""] = val ?? SimCmd.create();
  }
  internalBinaryWrite(
    message: SimCmdMap,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, game.simenv.SimCmd> cmds = 1; */
    for (let k of Object.keys(message.cmds)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      SimCmd.internalBinaryWrite(message.cmds[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.bff.SimCmdMap
 */
export const SimCmdMap = new SimCmdMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimInfoMap$Type extends MessageType<SimInfoMap> {
  constructor() {
    super("game.bff.SimInfoMap", [
      {
        no: 1,
        name: "infos",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => SimInfo },
      },
    ]);
  }
  create(value?: PartialMessage<SimInfoMap>): SimInfoMap {
    const message = { infos: {} };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<SimInfoMap>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SimInfoMap
  ): SimInfoMap {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.simenv.SimInfo> infos */ 1:
          this.binaryReadMap1(message.infos, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: SimInfoMap["infos"],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof SimInfoMap["infos"] | undefined,
      val: SimInfoMap["infos"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = SimInfo.internalBinaryRead(reader, reader.uint32(), options);
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.bff.SimInfoMap.infos"
          );
      }
    }
    map[key ?? ""] = val ?? SimInfo.create();
  }
  internalBinaryWrite(
    message: SimInfoMap,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, game.simenv.SimInfo> infos = 1; */
    for (let k of Object.keys(message.infos)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      SimInfo.internalBinaryWrite(message.infos[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.bff.SimInfoMap
 */
export const SimInfoMap = new SimInfoMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgentConfigMap$Type extends MessageType<AgentConfigMap> {
  constructor() {
    super("game.bff.AgentConfigMap", [
      {
        no: 1,
        name: "configs",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => AgentConfig },
      },
    ]);
  }
  create(value?: PartialMessage<AgentConfigMap>): AgentConfigMap {
    const message = { configs: {} };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<AgentConfigMap>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AgentConfigMap
  ): AgentConfigMap {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.agent.AgentConfig> configs */ 1:
          this.binaryReadMap1(message.configs, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: AgentConfigMap["configs"],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof AgentConfigMap["configs"] | undefined,
      val: AgentConfigMap["configs"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = AgentConfig.internalBinaryRead(
            reader,
            reader.uint32(),
            options
          );
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.bff.AgentConfigMap.configs"
          );
      }
    }
    map[key ?? ""] = val ?? AgentConfig.create();
  }
  internalBinaryWrite(
    message: AgentConfigMap,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, game.agent.AgentConfig> configs = 1; */
    for (let k of Object.keys(message.configs)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      AgentConfig.internalBinaryWrite(message.configs[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.bff.AgentConfigMap
 */
export const AgentConfigMap = new AgentConfigMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgentModeMap$Type extends MessageType<AgentModeMap> {
  constructor() {
    super("game.bff.AgentModeMap", [
      {
        no: 1,
        name: "modes",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => AgentMode },
      },
    ]);
  }
  create(value?: PartialMessage<AgentModeMap>): AgentModeMap {
    const message = { modes: {} };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<AgentModeMap>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AgentModeMap
  ): AgentModeMap {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.agent.AgentMode> modes */ 1:
          this.binaryReadMap1(message.modes, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: AgentModeMap["modes"],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof AgentModeMap["modes"] | undefined,
      val: AgentModeMap["modes"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = AgentMode.internalBinaryRead(reader, reader.uint32(), options);
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.bff.AgentModeMap.modes"
          );
      }
    }
    map[key ?? ""] = val ?? AgentMode.create();
  }
  internalBinaryWrite(
    message: AgentModeMap,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, game.agent.AgentMode> modes = 1; */
    for (let k of Object.keys(message.modes)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      AgentMode.internalBinaryWrite(message.modes[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.bff.AgentModeMap
 */
export const AgentModeMap = new AgentModeMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModelWeightsMap$Type extends MessageType<ModelWeightsMap> {
  constructor() {
    super("game.bff.ModelWeightsMap", [
      {
        no: 1,
        name: "weights",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => ModelWeights },
      },
    ]);
  }
  create(value?: PartialMessage<ModelWeightsMap>): ModelWeightsMap {
    const message = { weights: {} };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<ModelWeightsMap>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ModelWeightsMap
  ): ModelWeightsMap {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.agent.ModelWeights> weights */ 1:
          this.binaryReadMap1(message.weights, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: ModelWeightsMap["weights"],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof ModelWeightsMap["weights"] | undefined,
      val: ModelWeightsMap["weights"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = ModelWeights.internalBinaryRead(
            reader,
            reader.uint32(),
            options
          );
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.bff.ModelWeightsMap.weights"
          );
      }
    }
    map[key ?? ""] = val ?? ModelWeights.create();
  }
  internalBinaryWrite(
    message: ModelWeightsMap,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, game.agent.ModelWeights> weights = 1; */
    for (let k of Object.keys(message.weights)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      ModelWeights.internalBinaryWrite(message.weights[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.bff.ModelWeightsMap
 */
export const ModelWeightsMap = new ModelWeightsMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModelBufferMap$Type extends MessageType<ModelBufferMap> {
  constructor() {
    super("game.bff.ModelBufferMap", [
      {
        no: 1,
        name: "buffers",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => ModelBuffer },
      },
    ]);
  }
  create(value?: PartialMessage<ModelBufferMap>): ModelBufferMap {
    const message = { buffers: {} };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<ModelBufferMap>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ModelBufferMap
  ): ModelBufferMap {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.agent.ModelBuffer> buffers */ 1:
          this.binaryReadMap1(message.buffers, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: ModelBufferMap["buffers"],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof ModelBufferMap["buffers"] | undefined,
      val: ModelBufferMap["buffers"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = ModelBuffer.internalBinaryRead(
            reader,
            reader.uint32(),
            options
          );
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.bff.ModelBufferMap.buffers"
          );
      }
    }
    map[key ?? ""] = val ?? ModelBuffer.create();
  }
  internalBinaryWrite(
    message: ModelBufferMap,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, game.agent.ModelBuffer> buffers = 1; */
    for (let k of Object.keys(message.buffers)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      ModelBuffer.internalBinaryWrite(message.buffers[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.bff.ModelBufferMap
 */
export const ModelBufferMap = new ModelBufferMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ModelStatusMap$Type extends MessageType<ModelStatusMap> {
  constructor() {
    super("game.bff.ModelStatusMap", [
      {
        no: 1,
        name: "status",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => ModelStatus },
      },
    ]);
  }
  create(value?: PartialMessage<ModelStatusMap>): ModelStatusMap {
    const message = { status: {} };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<ModelStatusMap>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ModelStatusMap
  ): ModelStatusMap {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.agent.ModelStatus> status */ 1:
          this.binaryReadMap1(message.status, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: ModelStatusMap["status"],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof ModelStatusMap["status"] | undefined,
      val: ModelStatusMap["status"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = ModelStatus.internalBinaryRead(
            reader,
            reader.uint32(),
            options
          );
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.bff.ModelStatusMap.status"
          );
      }
    }
    map[key ?? ""] = val ?? ModelStatus.create();
  }
  internalBinaryWrite(
    message: ModelStatusMap,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, game.agent.ModelStatus> status = 1; */
    for (let k of Object.keys(message.status)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      ModelStatus.internalBinaryWrite(message.status[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.bff.ModelStatusMap
 */
export const ModelStatusMap = new ModelStatusMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CallDataMap$Type extends MessageType<CallDataMap> {
  constructor() {
    super("game.bff.CallDataMap", [
      {
        no: 1,
        name: "data",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => CallData },
      },
    ]);
  }
  create(value?: PartialMessage<CallDataMap>): CallDataMap {
    const message = { data: {} };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CallDataMap>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CallDataMap
  ): CallDataMap {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.types.CallData> data */ 1:
          this.binaryReadMap1(message.data, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: CallDataMap["data"],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof CallDataMap["data"] | undefined,
      val: CallDataMap["data"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = CallData.internalBinaryRead(reader, reader.uint32(), options);
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.bff.CallDataMap.data"
          );
      }
    }
    map[key ?? ""] = val ?? CallData.create();
  }
  internalBinaryWrite(
    message: CallDataMap,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, game.types.CallData> data = 1; */
    for (let k of Object.keys(message.data)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      CallData.internalBinaryWrite(message.data[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.bff.CallDataMap
 */
export const CallDataMap = new CallDataMap$Type();
/**
 * @generated ServiceType for protobuf service game.bff.BFF
 */
export const BFF = new ServiceType("game.bff.BFF", [
  { name: "ResetServer", options: {}, I: CommonRequest, O: CommonResponse },
  {
    name: "RegisterService",
    options: {},
    I: ServiceInfoMap,
    O: CommonResponse,
  },
  {
    name: "UnRegisterService",
    options: {},
    I: ServiceIdList,
    O: CommonResponse,
  },
  { name: "GetServiceInfo", options: {}, I: ServiceIdList, O: ServiceInfoMap },
  { name: "SetServiceInfo", options: {}, I: ServiceInfoMap, O: CommonResponse },
  { name: "GetRouteConfig", options: {}, I: CommonRequest, O: RouteConfig },
  { name: "SetRouteConfig", options: {}, I: RouteConfig, O: CommonResponse },
  { name: "ResetService", options: {}, I: ServiceIdList, O: CommonResponse },
  { name: "QueryService", options: {}, I: ServiceIdList, O: ServiceStateMap },
  {
    name: "GetSimenvConfig",
    options: {},
    I: ServiceIdList,
    O: SimenvConfigMap,
  },
  {
    name: "SetSimenvConfig",
    options: {},
    I: SimenvConfigMap,
    O: CommonResponse,
  },
  { name: "SimControl", options: {}, I: SimCmdMap, O: CommonResponse },
  { name: "SimMonitor", options: {}, I: ServiceIdList, O: SimInfoMap },
  { name: "GetAgentConfig", options: {}, I: ServiceIdList, O: AgentConfigMap },
  { name: "SetAgentConfig", options: {}, I: AgentConfigMap, O: CommonResponse },
  { name: "GetAgentMode", options: {}, I: ServiceIdList, O: AgentModeMap },
  { name: "SetAgentMode", options: {}, I: AgentModeMap, O: CommonResponse },
  {
    name: "GetModelWeights",
    options: {},
    I: ServiceIdList,
    O: ModelWeightsMap,
  },
  {
    name: "SetModelWeights",
    options: {},
    I: ModelWeightsMap,
    O: CommonResponse,
  },
  { name: "GetModelBuffer", options: {}, I: ServiceIdList, O: ModelBufferMap },
  { name: "SetModelBuffer", options: {}, I: ModelBufferMap, O: CommonResponse },
  { name: "GetModelStatus", options: {}, I: ServiceIdList, O: ModelStatusMap },
  { name: "SetModelStatus", options: {}, I: ModelStatusMap, O: CommonResponse },
  { name: "Call", options: {}, I: CallDataMap, O: CallDataMap },
]);
