// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "types.proto" (package "game.types", syntax proto3)
// tslint:disable
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message game.types.CommonRequest
 */
export interface CommonRequest {}
/**
 * @generated from protobuf message game.types.CommonResponse
 */
export interface CommonResponse {}
/**
 * @generated from protobuf message game.types.CallData
 */
export interface CallData {
  /**
   * @generated from protobuf field: string identity = 1;
   */
  identity: string; // identity of call
  /**
   * @generated from protobuf field: string str_data = 2;
   */
  strData: string; // string data
  /**
   * @generated from protobuf field: bytes bin_data = 3;
   */
  binData: Uint8Array; // binary data
}
/**
 * @generated from protobuf message game.types.ServiceState
 */
export interface ServiceState {
  /**
   * @generated from protobuf field: game.types.ServiceState.State state = 1;
   */
  state: ServiceState_State;
}
/**
 * @generated from protobuf enum game.types.ServiceState.State
 */
export enum ServiceState_State {
  /**
   * @generated from protobuf enum value: UNINITED = 0;
   */
  UNINITED = 0,
  /**
   * @generated from protobuf enum value: INITED = 1;
   */
  INITED = 1,
}
/**
 * @generated from protobuf message game.types.SimParam
 */
export interface SimParam {
  /**
   * @generated from protobuf oneof: value
   */
  value:
    | {
        oneofKind: "doubleValue";
        /**
         * @generated from protobuf field: double double_value = 1;
         */
        doubleValue: number;
      }
    | {
        oneofKind: "int32Value";
        /**
         * @generated from protobuf field: int32 int32_value = 2;
         */
        int32Value: number;
      }
    | {
        oneofKind: "boolValue";
        /**
         * @generated from protobuf field: bool bool_value = 3;
         */
        boolValue: boolean;
      }
    | {
        oneofKind: "stringValue";
        /**
         * @generated from protobuf field: string string_value = 4;
         */
        stringValue: string;
      }
    | {
        oneofKind: "arrayValue";
        /**
         * @generated from protobuf field: game.types.SimParam.Array array_value = 5;
         */
        arrayValue: SimParam_Array;
      }
    | {
        oneofKind: "structValue";
        /**
         * @generated from protobuf field: game.types.SimParam.Struct struct_value = 6;
         */
        structValue: SimParam_Struct;
      }
    | {
        oneofKind: undefined;
      };
}
/**
 * @generated from protobuf message game.types.SimParam.Array
 */
export interface SimParam_Array {
  /**
   * @generated from protobuf field: repeated game.types.SimParam items = 1;
   */
  items: SimParam[]; // items in array
}
/**
 * @generated from protobuf message game.types.SimParam.Struct
 */
export interface SimParam_Struct {
  /**
   * @generated from protobuf field: map<string, game.types.SimParam> fields = 1;
   */
  fields: {
    [key: string]: SimParam;
  }; // <field name, field value>
}
/**
 * @generated from protobuf message game.types.SimEntity
 */
export interface SimEntity {
  /**
   * @generated from protobuf field: map<string, game.types.SimParam> params = 1;
   */
  params: {
    [key: string]: SimParam;
  }; // <param name, param value>
}
/**
 * @generated from protobuf message game.types.SimModel
 */
export interface SimModel {
  /**
   * @generated from protobuf field: repeated game.types.SimEntity entities = 1;
   */
  entities: SimEntity[]; // entities data of model
}
/**
 * @generated from protobuf message game.types.SimState
 */
export interface SimState {
  /**
   * @generated from protobuf field: map<string, game.types.SimModel> states = 1;
   */
  states: {
    [key: string]: SimModel;
  }; // <model name, model data>
  /**
   * @generated from protobuf field: bool terminated = 2;
   */
  terminated: boolean;
  /**
   * @generated from protobuf field: bool truncated = 3;
   */
  truncated: boolean;
}
/**
 * @generated from protobuf message game.types.SimAction
 */
export interface SimAction {
  /**
   * @generated from protobuf field: map<string, game.types.SimModel> actions = 1;
   */
  actions: {
    [key: string]: SimModel;
  }; // <model name, model data>
}
// @generated message type with reflection information, may provide speed optimized methods
class CommonRequest$Type extends MessageType<CommonRequest> {
  constructor() {
    super("game.types.CommonRequest", []);
  }
  create(value?: PartialMessage<CommonRequest>): CommonRequest {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CommonRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CommonRequest
  ): CommonRequest {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CommonRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.CommonRequest
 */
export const CommonRequest = new CommonRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommonResponse$Type extends MessageType<CommonResponse> {
  constructor() {
    super("game.types.CommonResponse", []);
  }
  create(value?: PartialMessage<CommonResponse>): CommonResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CommonResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CommonResponse
  ): CommonResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CommonResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.CommonResponse
 */
export const CommonResponse = new CommonResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CallData$Type extends MessageType<CallData> {
  constructor() {
    super("game.types.CallData", [
      { no: 1, name: "identity", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "str_data", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "bin_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<CallData>): CallData {
    const message = { identity: "", strData: "", binData: new Uint8Array(0) };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CallData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CallData
  ): CallData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string identity */ 1:
          message.identity = reader.string();
          break;
        case /* string str_data */ 2:
          message.strData = reader.string();
          break;
        case /* bytes bin_data */ 3:
          message.binData = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CallData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* string identity = 1; */
    if (message.identity !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.identity);
    /* string str_data = 2; */
    if (message.strData !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.strData);
    /* bytes bin_data = 3; */
    if (message.binData.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.binData);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.CallData
 */
export const CallData = new CallData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceState$Type extends MessageType<ServiceState> {
  constructor() {
    super("game.types.ServiceState", [
      {
        no: 1,
        name: "state",
        kind: "enum",
        T: () => ["game.types.ServiceState.State", ServiceState_State],
      },
    ]);
  }
  create(value?: PartialMessage<ServiceState>): ServiceState {
    const message = { state: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<ServiceState>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ServiceState
  ): ServiceState {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* game.types.ServiceState.State state */ 1:
          message.state = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ServiceState,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* game.types.ServiceState.State state = 1; */
    if (message.state !== 0)
      writer.tag(1, WireType.Varint).int32(message.state);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.ServiceState
 */
export const ServiceState = new ServiceState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimParam$Type extends MessageType<SimParam> {
  constructor() {
    super("game.types.SimParam", [
      {
        no: 1,
        name: "double_value",
        kind: "scalar",
        oneof: "value",
        T: 1 /*ScalarType.DOUBLE*/,
      },
      {
        no: 2,
        name: "int32_value",
        kind: "scalar",
        oneof: "value",
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "bool_value",
        kind: "scalar",
        oneof: "value",
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 4,
        name: "string_value",
        kind: "scalar",
        oneof: "value",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 5,
        name: "array_value",
        kind: "message",
        oneof: "value",
        T: () => SimParam_Array,
      },
      {
        no: 6,
        name: "struct_value",
        kind: "message",
        oneof: "value",
        T: () => SimParam_Struct,
      },
    ]);
  }
  create(value?: PartialMessage<SimParam>): SimParam {
    const message = { value: { oneofKind: undefined } };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<SimParam>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SimParam
  ): SimParam {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double double_value */ 1:
          message.value = {
            oneofKind: "doubleValue",
            doubleValue: reader.double(),
          };
          break;
        case /* int32 int32_value */ 2:
          message.value = {
            oneofKind: "int32Value",
            int32Value: reader.int32(),
          };
          break;
        case /* bool bool_value */ 3:
          message.value = {
            oneofKind: "boolValue",
            boolValue: reader.bool(),
          };
          break;
        case /* string string_value */ 4:
          message.value = {
            oneofKind: "stringValue",
            stringValue: reader.string(),
          };
          break;
        case /* game.types.SimParam.Array array_value */ 5:
          message.value = {
            oneofKind: "arrayValue",
            arrayValue: SimParam_Array.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.value as any).arrayValue
            ),
          };
          break;
        case /* game.types.SimParam.Struct struct_value */ 6:
          message.value = {
            oneofKind: "structValue",
            structValue: SimParam_Struct.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.value as any).structValue
            ),
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SimParam,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* double double_value = 1; */
    if (message.value.oneofKind === "doubleValue")
      writer.tag(1, WireType.Bit64).double(message.value.doubleValue);
    /* int32 int32_value = 2; */
    if (message.value.oneofKind === "int32Value")
      writer.tag(2, WireType.Varint).int32(message.value.int32Value);
    /* bool bool_value = 3; */
    if (message.value.oneofKind === "boolValue")
      writer.tag(3, WireType.Varint).bool(message.value.boolValue);
    /* string string_value = 4; */
    if (message.value.oneofKind === "stringValue")
      writer.tag(4, WireType.LengthDelimited).string(message.value.stringValue);
    /* game.types.SimParam.Array array_value = 5; */
    if (message.value.oneofKind === "arrayValue")
      SimParam_Array.internalBinaryWrite(
        message.value.arrayValue,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options
      ).join();
    /* game.types.SimParam.Struct struct_value = 6; */
    if (message.value.oneofKind === "structValue")
      SimParam_Struct.internalBinaryWrite(
        message.value.structValue,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.SimParam
 */
export const SimParam = new SimParam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimParam_Array$Type extends MessageType<SimParam_Array> {
  constructor() {
    super("game.types.SimParam.Array", [
      {
        no: 1,
        name: "items",
        kind: "message",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => SimParam,
      },
    ]);
  }
  create(value?: PartialMessage<SimParam_Array>): SimParam_Array {
    const message = { items: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<SimParam_Array>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SimParam_Array
  ): SimParam_Array {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated game.types.SimParam items */ 1:
          message.items.push(
            SimParam.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SimParam_Array,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated game.types.SimParam items = 1; */
    for (let i = 0; i < message.items.length; i++)
      SimParam.internalBinaryWrite(
        message.items[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.SimParam.Array
 */
export const SimParam_Array = new SimParam_Array$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimParam_Struct$Type extends MessageType<SimParam_Struct> {
  constructor() {
    super("game.types.SimParam.Struct", [
      {
        no: 1,
        name: "fields",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => SimParam },
      },
    ]);
  }
  create(value?: PartialMessage<SimParam_Struct>): SimParam_Struct {
    const message = { fields: {} };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<SimParam_Struct>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SimParam_Struct
  ): SimParam_Struct {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.types.SimParam> fields */ 1:
          this.binaryReadMap1(message.fields, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: SimParam_Struct["fields"],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof SimParam_Struct["fields"] | undefined,
      val: SimParam_Struct["fields"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = SimParam.internalBinaryRead(reader, reader.uint32(), options);
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.types.SimParam.Struct.fields"
          );
      }
    }
    map[key ?? ""] = val ?? SimParam.create();
  }
  internalBinaryWrite(
    message: SimParam_Struct,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, game.types.SimParam> fields = 1; */
    for (let k of Object.keys(message.fields)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      SimParam.internalBinaryWrite(message.fields[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.SimParam.Struct
 */
export const SimParam_Struct = new SimParam_Struct$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimEntity$Type extends MessageType<SimEntity> {
  constructor() {
    super("game.types.SimEntity", [
      {
        no: 1,
        name: "params",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => SimParam },
      },
    ]);
  }
  create(value?: PartialMessage<SimEntity>): SimEntity {
    const message = { params: {} };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<SimEntity>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SimEntity
  ): SimEntity {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.types.SimParam> params */ 1:
          this.binaryReadMap1(message.params, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: SimEntity["params"],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof SimEntity["params"] | undefined,
      val: SimEntity["params"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = SimParam.internalBinaryRead(reader, reader.uint32(), options);
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.types.SimEntity.params"
          );
      }
    }
    map[key ?? ""] = val ?? SimParam.create();
  }
  internalBinaryWrite(
    message: SimEntity,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, game.types.SimParam> params = 1; */
    for (let k of Object.keys(message.params)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      SimParam.internalBinaryWrite(message.params[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.SimEntity
 */
export const SimEntity = new SimEntity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimModel$Type extends MessageType<SimModel> {
  constructor() {
    super("game.types.SimModel", [
      {
        no: 1,
        name: "entities",
        kind: "message",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => SimEntity,
      },
    ]);
  }
  create(value?: PartialMessage<SimModel>): SimModel {
    const message = { entities: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<SimModel>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SimModel
  ): SimModel {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated game.types.SimEntity entities */ 1:
          message.entities.push(
            SimEntity.internalBinaryRead(reader, reader.uint32(), options)
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SimModel,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* repeated game.types.SimEntity entities = 1; */
    for (let i = 0; i < message.entities.length; i++)
      SimEntity.internalBinaryWrite(
        message.entities[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.SimModel
 */
export const SimModel = new SimModel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimState$Type extends MessageType<SimState> {
  constructor() {
    super("game.types.SimState", [
      {
        no: 1,
        name: "states",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => SimModel },
      },
      { no: 2, name: "terminated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 3, name: "truncated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
    ]);
  }
  create(value?: PartialMessage<SimState>): SimState {
    const message = { states: {}, terminated: false, truncated: false };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<SimState>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SimState
  ): SimState {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.types.SimModel> states */ 1:
          this.binaryReadMap1(message.states, reader, options);
          break;
        case /* bool terminated */ 2:
          message.terminated = reader.bool();
          break;
        case /* bool truncated */ 3:
          message.truncated = reader.bool();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: SimState["states"],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof SimState["states"] | undefined,
      val: SimState["states"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = SimModel.internalBinaryRead(reader, reader.uint32(), options);
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.types.SimState.states"
          );
      }
    }
    map[key ?? ""] = val ?? SimModel.create();
  }
  internalBinaryWrite(
    message: SimState,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, game.types.SimModel> states = 1; */
    for (let k of Object.keys(message.states)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      SimModel.internalBinaryWrite(message.states[k], writer, options);
      writer.join().join();
    }
    /* bool terminated = 2; */
    if (message.terminated !== false)
      writer.tag(2, WireType.Varint).bool(message.terminated);
    /* bool truncated = 3; */
    if (message.truncated !== false)
      writer.tag(3, WireType.Varint).bool(message.truncated);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.SimState
 */
export const SimState = new SimState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimAction$Type extends MessageType<SimAction> {
  constructor() {
    super("game.types.SimAction", [
      {
        no: 1,
        name: "actions",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => SimModel },
      },
    ]);
  }
  create(value?: PartialMessage<SimAction>): SimAction {
    const message = { actions: {} };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<SimAction>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SimAction
  ): SimAction {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.types.SimModel> actions */ 1:
          this.binaryReadMap1(message.actions, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: SimAction["actions"],
    reader: IBinaryReader,
    options: BinaryReadOptions
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof SimAction["actions"] | undefined,
      val: SimAction["actions"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = SimModel.internalBinaryRead(reader, reader.uint32(), options);
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.types.SimAction.actions"
          );
      }
    }
    map[key ?? ""] = val ?? SimModel.create();
  }
  internalBinaryWrite(
    message: SimAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions
  ): IBinaryWriter {
    /* map<string, game.types.SimModel> actions = 1; */
    for (let k of Object.keys(message.actions)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      SimModel.internalBinaryWrite(message.actions[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.SimAction
 */
export const SimAction = new SimAction$Type();
