// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "types.proto" (package "game.types", syntax proto3)
// tslint:disable
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message game.types.CommonRequest
 */
export interface CommonRequest {}
/**
 * @generated from protobuf message game.types.CommonResponse
 */
export interface CommonResponse {}
/**
 * @generated from protobuf message game.types.CallData
 */
export interface CallData {
  /**
   * @generated from protobuf field: string name = 1;
   */
  name: string; // name of call
  /**
   * @generated from protobuf field: string dstr = 2;
   */
  dstr: string; // string data
  /**
   * @generated from protobuf field: bytes dbin = 3;
   */
  dbin: Uint8Array; // binary data
}
/**
 * @generated from protobuf message game.types.ServiceState
 */
export interface ServiceState {
  /**
   * @generated from protobuf field: game.types.ServiceState.State state = 1;
   */
  state: ServiceState_State; // state of service
}
/**
 * @generated from protobuf enum game.types.ServiceState.State
 */
export enum ServiceState_State {
  /**
   * service is not inited
   *
   * @generated from protobuf enum value: UNINITED = 0;
   */
  UNINITED = 0,
  /**
   * service is inited
   *
   * @generated from protobuf enum value: INITED = 1;
   */
  INITED = 1,
}
/**
 * @generated from protobuf message game.types.SimParam
 */
export interface SimParam {
  /**
   * @generated from protobuf oneof: value
   */
  value:
    | {
        oneofKind: "vdouble";
        /**
         * @generated from protobuf field: double vdouble = 1;
         */
        vdouble: number; // double value
      }
    | {
        oneofKind: "vint32";
        /**
         * @generated from protobuf field: int32 vint32 = 2;
         */
        vint32: number; // int32 value
      }
    | {
        oneofKind: "vbool";
        /**
         * @generated from protobuf field: bool vbool = 3;
         */
        vbool: boolean; // bool value
      }
    | {
        oneofKind: "vstring";
        /**
         * @generated from protobuf field: string vstring = 4;
         */
        vstring: string; // string value
      }
    | {
        oneofKind: "varray";
        /**
         * @generated from protobuf field: game.types.SimParam.Array varray = 5;
         */
        varray: SimParam_Array; // array value
      }
    | {
        oneofKind: "vstruct";
        /**
         * @generated from protobuf field: game.types.SimParam.Struct vstruct = 6;
         */
        vstruct: SimParam_Struct; // struct value
      }
    | {
        oneofKind: undefined;
      };
}
/**
 * @generated from protobuf message game.types.SimParam.Array
 */
export interface SimParam_Array {
  /**
   * @generated from protobuf field: repeated game.types.SimParam items = 1;
   */
  items: SimParam[]; // items in array
}
/**
 * @generated from protobuf message game.types.SimParam.Struct
 */
export interface SimParam_Struct {
  /**
   * @generated from protobuf field: map<string, game.types.SimParam> fields = 1;
   */
  fields: {
    [key: string]: SimParam;
  }; // <field name, field value>
}
/**
 * @generated from protobuf message game.types.SimEntity
 */
export interface SimEntity {
  /**
   * @generated from protobuf field: map<string, game.types.SimParam> params = 1;
   */
  params: {
    [key: string]: SimParam;
  }; // <param name, param value>
}
/**
 * @generated from protobuf message game.types.SimModel
 */
export interface SimModel {
  /**
   * @generated from protobuf field: repeated game.types.SimEntity entities = 1;
   */
  entities: SimEntity[]; // entities data of model
}
/**
 * @generated from protobuf message game.types.SimState
 */
export interface SimState {
  /**
   * @generated from protobuf field: map<string, game.types.SimModel> states = 1;
   */
  states: {
    [key: string]: SimModel;
  }; // <model name, model data>
  /**
   * @generated from protobuf field: bool terminated = 2;
   */
  terminated: boolean; // whether `terminal state` is reached
  /**
   * @generated from protobuf field: bool truncated = 3;
   */
  truncated: boolean; // whether `truncation condition` is satisfied.
  /**
   * @generated from protobuf field: double reward = 4;
   */
  reward: number; // reward of this state
}
/**
 * @generated from protobuf message game.types.SimAction
 */
export interface SimAction {
  /**
   * @generated from protobuf field: map<string, game.types.SimModel> actions = 1;
   */
  actions: {
    [key: string]: SimModel;
  }; // <model name, model data>
}
// @generated message type with reflection information, may provide speed optimized methods
class CommonRequest$Type extends MessageType<CommonRequest> {
  constructor() {
    super("game.types.CommonRequest", []);
  }
  create(value?: PartialMessage<CommonRequest>): CommonRequest {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CommonRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CommonRequest,
  ): CommonRequest {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CommonRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.CommonRequest
 */
export const CommonRequest = new CommonRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CommonResponse$Type extends MessageType<CommonResponse> {
  constructor() {
    super("game.types.CommonResponse", []);
  }
  create(value?: PartialMessage<CommonResponse>): CommonResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CommonResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CommonResponse,
  ): CommonResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: CommonResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.CommonResponse
 */
export const CommonResponse = new CommonResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CallData$Type extends MessageType<CallData> {
  constructor() {
    super("game.types.CallData", [
      { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 2, name: "dstr", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
      { no: 3, name: "dbin", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ]);
  }
  create(value?: PartialMessage<CallData>): CallData {
    const message = { name: "", dstr: "", dbin: new Uint8Array(0) };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<CallData>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: CallData,
  ): CallData {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string name */ 1:
          message.name = reader.string();
          break;
        case /* string dstr */ 2:
          message.dstr = reader.string();
          break;
        case /* bytes dbin */ 3:
          message.dbin = reader.bytes();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: CallData,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string name = 1; */
    if (message.name !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.name);
    /* string dstr = 2; */
    if (message.dstr !== "")
      writer.tag(2, WireType.LengthDelimited).string(message.dstr);
    /* bytes dbin = 3; */
    if (message.dbin.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.dbin);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.CallData
 */
export const CallData = new CallData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ServiceState$Type extends MessageType<ServiceState> {
  constructor() {
    super("game.types.ServiceState", [
      {
        no: 1,
        name: "state",
        kind: "enum",
        T: () => ["game.types.ServiceState.State", ServiceState_State],
      },
    ]);
  }
  create(value?: PartialMessage<ServiceState>): ServiceState {
    const message = { state: 0 };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<ServiceState>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ServiceState,
  ): ServiceState {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* game.types.ServiceState.State state */ 1:
          message.state = reader.int32();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: ServiceState,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* game.types.ServiceState.State state = 1; */
    if (message.state !== 0)
      writer.tag(1, WireType.Varint).int32(message.state);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.ServiceState
 */
export const ServiceState = new ServiceState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimParam$Type extends MessageType<SimParam> {
  constructor() {
    super("game.types.SimParam", [
      {
        no: 1,
        name: "vdouble",
        kind: "scalar",
        oneof: "value",
        T: 1 /*ScalarType.DOUBLE*/,
      },
      {
        no: 2,
        name: "vint32",
        kind: "scalar",
        oneof: "value",
        T: 5 /*ScalarType.INT32*/,
      },
      {
        no: 3,
        name: "vbool",
        kind: "scalar",
        oneof: "value",
        T: 8 /*ScalarType.BOOL*/,
      },
      {
        no: 4,
        name: "vstring",
        kind: "scalar",
        oneof: "value",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 5,
        name: "varray",
        kind: "message",
        oneof: "value",
        T: () => SimParam_Array,
      },
      {
        no: 6,
        name: "vstruct",
        kind: "message",
        oneof: "value",
        T: () => SimParam_Struct,
      },
    ]);
  }
  create(value?: PartialMessage<SimParam>): SimParam {
    const message = { value: { oneofKind: undefined } };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<SimParam>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SimParam,
  ): SimParam {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* double vdouble */ 1:
          message.value = {
            oneofKind: "vdouble",
            vdouble: reader.double(),
          };
          break;
        case /* int32 vint32 */ 2:
          message.value = {
            oneofKind: "vint32",
            vint32: reader.int32(),
          };
          break;
        case /* bool vbool */ 3:
          message.value = {
            oneofKind: "vbool",
            vbool: reader.bool(),
          };
          break;
        case /* string vstring */ 4:
          message.value = {
            oneofKind: "vstring",
            vstring: reader.string(),
          };
          break;
        case /* game.types.SimParam.Array varray */ 5:
          message.value = {
            oneofKind: "varray",
            varray: SimParam_Array.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.value as any).varray,
            ),
          };
          break;
        case /* game.types.SimParam.Struct vstruct */ 6:
          message.value = {
            oneofKind: "vstruct",
            vstruct: SimParam_Struct.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.value as any).vstruct,
            ),
          };
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SimParam,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* double vdouble = 1; */
    if (message.value.oneofKind === "vdouble")
      writer.tag(1, WireType.Bit64).double(message.value.vdouble);
    /* int32 vint32 = 2; */
    if (message.value.oneofKind === "vint32")
      writer.tag(2, WireType.Varint).int32(message.value.vint32);
    /* bool vbool = 3; */
    if (message.value.oneofKind === "vbool")
      writer.tag(3, WireType.Varint).bool(message.value.vbool);
    /* string vstring = 4; */
    if (message.value.oneofKind === "vstring")
      writer.tag(4, WireType.LengthDelimited).string(message.value.vstring);
    /* game.types.SimParam.Array varray = 5; */
    if (message.value.oneofKind === "varray")
      SimParam_Array.internalBinaryWrite(
        message.value.varray,
        writer.tag(5, WireType.LengthDelimited).fork(),
        options,
      ).join();
    /* game.types.SimParam.Struct vstruct = 6; */
    if (message.value.oneofKind === "vstruct")
      SimParam_Struct.internalBinaryWrite(
        message.value.vstruct,
        writer.tag(6, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.SimParam
 */
export const SimParam = new SimParam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimParam_Array$Type extends MessageType<SimParam_Array> {
  constructor() {
    super("game.types.SimParam.Array", [
      {
        no: 1,
        name: "items",
        kind: "message",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => SimParam,
      },
    ]);
  }
  create(value?: PartialMessage<SimParam_Array>): SimParam_Array {
    const message = { items: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<SimParam_Array>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SimParam_Array,
  ): SimParam_Array {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated game.types.SimParam items */ 1:
          message.items.push(
            SimParam.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SimParam_Array,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated game.types.SimParam items = 1; */
    for (let i = 0; i < message.items.length; i++)
      SimParam.internalBinaryWrite(
        message.items[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.SimParam.Array
 */
export const SimParam_Array = new SimParam_Array$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimParam_Struct$Type extends MessageType<SimParam_Struct> {
  constructor() {
    super("game.types.SimParam.Struct", [
      {
        no: 1,
        name: "fields",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => SimParam },
      },
    ]);
  }
  create(value?: PartialMessage<SimParam_Struct>): SimParam_Struct {
    const message = { fields: {} };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<SimParam_Struct>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SimParam_Struct,
  ): SimParam_Struct {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.types.SimParam> fields */ 1:
          this.binaryReadMap1(message.fields, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: SimParam_Struct["fields"],
    reader: IBinaryReader,
    options: BinaryReadOptions,
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof SimParam_Struct["fields"] | undefined,
      val: SimParam_Struct["fields"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = SimParam.internalBinaryRead(reader, reader.uint32(), options);
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.types.SimParam.Struct.fields",
          );
      }
    }
    map[key ?? ""] = val ?? SimParam.create();
  }
  internalBinaryWrite(
    message: SimParam_Struct,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* map<string, game.types.SimParam> fields = 1; */
    for (let k of Object.keys(message.fields)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      SimParam.internalBinaryWrite(message.fields[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.SimParam.Struct
 */
export const SimParam_Struct = new SimParam_Struct$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimEntity$Type extends MessageType<SimEntity> {
  constructor() {
    super("game.types.SimEntity", [
      {
        no: 1,
        name: "params",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => SimParam },
      },
    ]);
  }
  create(value?: PartialMessage<SimEntity>): SimEntity {
    const message = { params: {} };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<SimEntity>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SimEntity,
  ): SimEntity {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.types.SimParam> params */ 1:
          this.binaryReadMap1(message.params, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: SimEntity["params"],
    reader: IBinaryReader,
    options: BinaryReadOptions,
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof SimEntity["params"] | undefined,
      val: SimEntity["params"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = SimParam.internalBinaryRead(reader, reader.uint32(), options);
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.types.SimEntity.params",
          );
      }
    }
    map[key ?? ""] = val ?? SimParam.create();
  }
  internalBinaryWrite(
    message: SimEntity,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* map<string, game.types.SimParam> params = 1; */
    for (let k of Object.keys(message.params)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      SimParam.internalBinaryWrite(message.params[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.SimEntity
 */
export const SimEntity = new SimEntity$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimModel$Type extends MessageType<SimModel> {
  constructor() {
    super("game.types.SimModel", [
      {
        no: 1,
        name: "entities",
        kind: "message",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => SimEntity,
      },
    ]);
  }
  create(value?: PartialMessage<SimModel>): SimModel {
    const message = { entities: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<SimModel>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SimModel,
  ): SimModel {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated game.types.SimEntity entities */ 1:
          message.entities.push(
            SimEntity.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SimModel,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated game.types.SimEntity entities = 1; */
    for (let i = 0; i < message.entities.length; i++)
      SimEntity.internalBinaryWrite(
        message.entities[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.SimModel
 */
export const SimModel = new SimModel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimState$Type extends MessageType<SimState> {
  constructor() {
    super("game.types.SimState", [
      {
        no: 1,
        name: "states",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => SimModel },
      },
      { no: 2, name: "terminated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 3, name: "truncated", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
      { no: 4, name: "reward", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
    ]);
  }
  create(value?: PartialMessage<SimState>): SimState {
    const message = {
      states: {},
      terminated: false,
      truncated: false,
      reward: 0,
    };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<SimState>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SimState,
  ): SimState {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.types.SimModel> states */ 1:
          this.binaryReadMap1(message.states, reader, options);
          break;
        case /* bool terminated */ 2:
          message.terminated = reader.bool();
          break;
        case /* bool truncated */ 3:
          message.truncated = reader.bool();
          break;
        case /* double reward */ 4:
          message.reward = reader.double();
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: SimState["states"],
    reader: IBinaryReader,
    options: BinaryReadOptions,
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof SimState["states"] | undefined,
      val: SimState["states"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = SimModel.internalBinaryRead(reader, reader.uint32(), options);
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.types.SimState.states",
          );
      }
    }
    map[key ?? ""] = val ?? SimModel.create();
  }
  internalBinaryWrite(
    message: SimState,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* map<string, game.types.SimModel> states = 1; */
    for (let k of Object.keys(message.states)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      SimModel.internalBinaryWrite(message.states[k], writer, options);
      writer.join().join();
    }
    /* bool terminated = 2; */
    if (message.terminated !== false)
      writer.tag(2, WireType.Varint).bool(message.terminated);
    /* bool truncated = 3; */
    if (message.truncated !== false)
      writer.tag(3, WireType.Varint).bool(message.truncated);
    /* double reward = 4; */
    if (message.reward !== 0)
      writer.tag(4, WireType.Bit64).double(message.reward);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.SimState
 */
export const SimState = new SimState$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimAction$Type extends MessageType<SimAction> {
  constructor() {
    super("game.types.SimAction", [
      {
        no: 1,
        name: "actions",
        kind: "map",
        K: 9 /*ScalarType.STRING*/,
        V: { kind: "message", T: () => SimModel },
      },
    ]);
  }
  create(value?: PartialMessage<SimAction>): SimAction {
    const message = { actions: {} };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<SimAction>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SimAction,
  ): SimAction {
    let message = target ?? this.create(),
      end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* map<string, game.types.SimModel> actions */ 1:
          this.binaryReadMap1(message.actions, reader, options);
          break;
        default:
          let u = options.readUnknownField;
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  private binaryReadMap1(
    map: SimAction["actions"],
    reader: IBinaryReader,
    options: BinaryReadOptions,
  ): void {
    let len = reader.uint32(),
      end = reader.pos + len,
      key: keyof SimAction["actions"] | undefined,
      val: SimAction["actions"][any] | undefined;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = reader.string();
          break;
        case 2:
          val = SimModel.internalBinaryRead(reader, reader.uint32(), options);
          break;
        default:
          throw new globalThis.Error(
            "unknown map entry field for field game.types.SimAction.actions",
          );
      }
    }
    map[key ?? ""] = val ?? SimModel.create();
  }
  internalBinaryWrite(
    message: SimAction,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* map<string, game.types.SimModel> actions = 1; */
    for (let k of Object.keys(message.actions)) {
      writer
        .tag(1, WireType.LengthDelimited)
        .fork()
        .tag(1, WireType.LengthDelimited)
        .string(k);
      writer.tag(2, WireType.LengthDelimited).fork();
      SimModel.internalBinaryWrite(message.actions[k], writer, options);
      writer.join().join();
    }
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message game.types.SimAction
 */
export const SimAction = new SimAction$Type();
